# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L5fKx4pxhDm6tjQkS0IUVzYWTY6U52bY

# Installing Required Packages
"""

!pip install langchain beautifulsoup4 flask sentence-transformers faiss-cpu

pip install -U langchain-community

"""# Extracting Data from URL using Langchain URL Loaders and BeautifulSoup"""

from langchain.document_loaders import WebBaseLoader
from bs4 import BeautifulSoup
import requests

# Define the URL
url = "https://brainlox.com/courses/category/technical"

# Create a loader for the URL
loader = WebBaseLoader([url])

# Load the HTML content
docs = loader.load()

# Using BeautifulSoup to extract course details
response = requests.get(url)
soup = BeautifulSoup(response.text, 'html.parser')

# Extracting course titles, descriptions, and prices
courses = []
for course in soup.find_all('div', class_='single-courses-box'):
    title = course.find('h3').get_text(strip=True)
    description = course.find('p').get_text(strip=True)
    price = course.find('span', class_='price-per-session').get_text(strip=True)
    courses.append({'title': title, 'description': description, 'price': price})

# Print the extracted data
print(f"Extracted {len(courses)} courses.")

"""# Creating Embeddings and Store them in a Vector Store (FAISS)"""

from sentence_transformers import SentenceTransformer
from langchain.vectorstores import FAISS
from langchain.docstore import InMemoryDocstore
from langchain.docstore.document import Document
import faiss
import numpy as np

# Load the model for creating embeddings
model = SentenceTransformer('all-MiniLM-L6-v2')

# Extract the course descriptions for embedding
course_descriptions = [course['description'] for course in courses]

# Generate embeddings for the course descriptions
embeddings = model.encode(course_descriptions)

# Create a FAISS index for L2 distance (Euclidean distance)
index = faiss.IndexFlatL2(embeddings.shape[1])
index.add(np.array(embeddings))

# Create documents for the FAISS vector store
documents = [Document(page_content=desc, metadata={"title": course["title"], "price": course["price"]}) for desc, course in zip(course_descriptions, courses)]

# Create an InMemoryDocstore to map embeddings to documents
docstore = InMemoryDocstore({i: doc for i, doc in enumerate(documents)})

# Create the FAISS vector store with index, docstore, and mapping
index_to_docstore_id = {i: i for i in range(len(documents))}  # Index to document ID mapping
vector_store = FAISS(embedding_function=model.encode, index=index, docstore=docstore, index_to_docstore_id=index_to_docstore_id)

# Save the FAISS index to disk
faiss.write_index(index, 'courses_vector_store.index')

"""# Creating a Flask RESTful API to Handle Conversation"""

from flask import Flask, request, jsonify
from threading import Thread, Event
import faiss
import numpy as np

# Load the FAISS index from disk
index = faiss.read_index('courses_vector_store.index')

# Create the Flask app
app = Flask(__name__)

@app.route('/chatbot', methods=['POST'])
def chatbot():
    # Get the user query from the POST request
    user_input = request.json.get('query')

    # Generate embeddings for the user query and reshape it to (1, embedding_dim)
    user_embedding = model.encode([user_input])
    user_embedding = np.array(user_embedding).reshape(1, -1)

    # Search for the most relevant course in the FAISS index
    distances, indices = index.search(user_embedding, k=1)
    matched_course = courses[indices[0][0]]

    # Return the course information as JSON
    return jsonify({
        'course_title': matched_course['title'],
        'description': matched_course['description'],
        'price': matched_course['price']
    })

# Event to signal the server to stop
stop_event = Event()

# Function to run the Flask app
def run_app():
    # Run the app until the stop_event is set
    app.run(port=5001)

# Start the Flask app in a separate thread
thread = Thread(target=run_app)
thread.start()

# Function to stop the server
def stop_server():
    stop_event.set()
    thread.join()

# Call stop_server() when you want to stop the server

"""# Testing the Chatbot API Using curl"""

!curl -X POST http://127.0.0.1:5001/chatbot -H "Content-Type: application/json" -d '{"query": "I want to learn JavaScript"}'